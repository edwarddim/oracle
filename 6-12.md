# Oracle 1Z0-071 Cheat Sheet (Sections 6–12)

# 6. Reporting Aggregated Data Using Group Functions
 -  The keyword DISTINCT is used to return only non-duplicate values or combinations of non-duplicate values in a query
 -  The keyword DISTINCT can be used with all group functions
 - NVL can also be used to replace null values

```sql
NVL(column_name, 0)
SELECT DISTINCT job_id
FROM employees;

SELECT AVG(NVL(commission_pct, 0))
FROM employees;
```
 - Following group functions can operate on a whole table or grouping of rows and produces one result
 - Group functions ignore null values
```sql
COUNT(*)      - Total number of rows
COUNT(col)    - Non-null values only
SUM(col)      - Total of numeric values
AVG(col)      - Average of values
MIN(col)      - Minimum value
MAX(col)      - Maximum value
VARIANCE()
STDDEV()
```
 - Group functions require that any column listed in the SELECT clause that is not part of a group function must be listed in a GROUP BY clause
 - If you include a group function (AVG, SUM, COUNT, MAX, MIN, STDDEV, VARIANCE) in a SELECT clause along with any
other individual columns, each individual column must also appear in the GROUP BY clause
 - You cannot use a column alias in the GROUP BY clause
 - The WHERE clause excludes rows before they are divided into groups
```sql
GROUP BY Example:
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
ORDER BY department_id;

SELECT department_id, MAX(salary)
FROM employees
WHERE last_name != 'King'
GROUP BY department_id;
```

```sql
SELECT MAX(salary), MIN(salary), MIN(employee_id)
FROM employees
WHERE department_id = 60;
```
 - In the same way you used the WHERE clause to restrict the rows that you selected, you can use the HAVING clause to restrict groups
 -  In a query using a GROUP BY and HAVING clause, the rows are first grouped, group functions are applied,
and then only those groups matching the HAVING clause are displayed
 -  The WHERE clause is used to restrict rows; the HAVING clause is used to restrict groups returned from a GROUP BY clause

```sql
HAVING Clause:
SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;

-- This query finds the average population of the countries in each region
-- It then only returns the region groups with a lowest population greater than three hundred thousand
SELECT region_id, ROUND(AVG(population))
FROM wf_countries
GROUP BY region_id
HAVING MIN(population)>300000
ORDER BY region_id;

-- Although the HAVING clause can precede the GROUP BY clause in a SELECT statement, it is recommended that you place each clause in the order shown. ORDER BY GOES LAST!
SELECT column, group_function
FROM table
WHERE
GROUP BY
HAVING
ORDER BY
```
## Rollup
 - In GROUP BY queries, you are quite often required to produce subtotals and totals, and the ROLLUP
operation can do that for you
 - ROLLUP creates subtotals that roll up from the most detailed level to a grand total, using the grouping list
specified in the GROUP BY clause
 -  The action of ROLLUP is straightforward: it creates subtotals that roll up from the most detailed level to a grand total
 -  ROLLUP uses an ordered list of grouping columns in its argument list 
 -  First, it calculates the standard aggregate values specified in the GROUP BY clause
 -  Next, it creates progressively higher-level subtotals, moving from right to left through the list of grouping columns
 -  Finally, it creates a grand total
```sql
-- In the result table below, the rows highlighted in red are generated by the ROLLUP operation
SELECT department_id, job_id, SUM(salary)
FROM employees
WHERE department_id < 50
GROUP BY ROLLUP (department_id, job_id);
```
![Rollup results](/imgs/rollup.png)

## Cube
 -  CUBE, like ROLLUP, is an extension to the GROUP BY clause
 -  It produces cross-tabulation reports
 -  It can be applied to all aggregate functions including AVG, SUM, MIN, MAX, and COUNT
 -  Columns listed in the GROUP BY clause are cross-referenced to create a superset of groups
 -  The aggregate functions specified in the SELECT list are applied to this group to create summary values for the additional super-aggregate rows
 -  CUBE is often used in queries that use columns from separate tables rather than separate columns from a single table
 -  Imagine, for example, a user querying the Sales table for a company like AMAZON.COM
 -  A commonly requested cross-tabulation report might include subtotals for all possible combinations of sales across a Month, Region, and Product

 ```sql
--  In the following statement, the rows in red are generated by the CUBE operation
SELECT department_id, job_id, SUM(salary)
FROM employees
WHERE department_id < 50
GROUP BY CUBE (department_id, job_id);
 ```
![Rollup results](/imgs/coube.png)

## Grouping Sets
 -  GROUPING SETS is another extension to the GROUP BY clause
 -  It is used to specify multiple groupings of data
 -  It gives you the functionality of having multiple GROUP BY clauses in the same SELECT statement, which is not allowed in the normal syntax
 -  If you want to see data from the EMPLOYEES table grouped by (department_id, job_id, manager_id)
 -  But also grouped by (department_id, manager_id)
 -  And also grouped by (job_id, manager_id), then you would normally have to write three different select statements with the only difference between them being the GROUP BY clauses
 - For the database, this means retrieving the same data three different times, and that can be quite a big overhead
 - Imagine if your company had 3,000,000 employees
 - Then you are asking the database to retrieve 9 million rows instead of just 3 million rows – quite a big difference
 - So GROUPING SETS are much more efficient when writing complex reports
![Grouping sets](/imgs/grouping_sets.png)

## Grouping Functions
 -  When you use ROLLUP or CUBE to create reports with subtotals, you quite often also have to be able to tell which rows in the output are actual rows returned from the database and which rows are computed subtotal rows resulting from the ROLLUP or CUBE operations
 -  The GROUPING function handles these problems
 -  Using a single column from the query as its argument, the GROUPING function will return a 1 for an aggregated (computed) row and a 0 for a non- aggregated (returned) row
 -  The syntax for the GROUPING is simply GROUPING (column_name)
 -  It is used only in the SELECT clause and it takes only a single column expression as the argument

```sql
SELECT department_id, job_id, SUM(salary),
  GROUPING(department_id) AS "Dept sub total",
  GROUPING(job_id) AS "Job sub total"
FROM employees
WHERE department_id < 50
GROUP BY CUBE (department_id, job_id);
```
![grouping function](/imgs/grouping_function.png)

# 7. Displaying Data from Multiple Tables Using Joins
 - CROSS JOINS return the two tables multiplied
```sql
-- Inner joins returns only matching rows
INNER JOIN:
SELECT e.first_name, d.department_name
FROM employees e
JOIN departments d ON (e.department_id = d.department_id);
```
```SQL
-- Outer joins all rows(matching and unmatched)
OUTER JOIN:
SELECT e.first_name, d.department_name
FROM employees e
LEFT JOIN departments d ON (e.department_id = d.department_id);
```

```SQL
USING Clause:
SELECT e.first_name, d.department_name
FROM employees e
JOIN departments d USING (department_id);

SELF JOIN:
SELECT worker.last_name, worker.manager_id, manager.last_name
AS "Manager name"
FROM employees worker JOIN employees manager
ON (worker.manager_id = manager.employee_id);

-- THREE TABLE JOIN:
SELECT last_name, department_name AS "Department", city
FROM employees JOIN departments USING (department_id)
JOIN locations USING (location_id);
```
 - OUTER JOIN and FULL OUTER JOIN is the same thing
![alt text](./imgs/joins_venn_diagram.png "Logo Title Text 1")

# 7.5 Hierarchical Queries (6-4)
 -  Hierarchical queries have their own new keywords: START WITH, CONNECT BY PRIOR, and LEVEL
 - START WITH identifies which row to use as the Root for the tree it i constructing, CONNECT BY PRIOR explains how to do the inter-row joins, and LEVEL specifies how
many branches deep the tree will traverse
```sql
SELECT employee_id, last_name, job_id, manager_id
FROM employees
START WITH employee_id = 100
CONNECT BY PRIOR employee_id = manager_id
```
 - LEVEL is a pseudo-column used with hierarchical queries, and it counts the number of steps it has taken from the root of the tree
```sql
SELECT LEVEL, last_name ||
' reports to ' ||
PRIOR last_name
AS "Walk Top Down"
FROM employees
START WITH last_name = 'King'
CONNECT BY PRIOR
employee_id = manager_id;
```
# 8. Using Subqueries to Solve Queries

```sql
Single-Row Subquery:
SELECT first_name
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

Multi-Row Subquery:
SELECT first_name
FROM employees
WHERE department_id IN (
  SELECT department_id FROM departments WHERE location_id = 1700
);

Correlated Subquery:
SELECT e1.first_name
FROM employees e1
WHERE salary > (
  SELECT AVG(salary)
  FROM employees e2
  WHERE e1.department_id = e2.department_id
);

EXISTS:
SELECT department_name
FROM departments d
WHERE EXISTS (
  SELECT 1 FROM employees e WHERE e.department_id = d.department_id
);
```

# 9. Using SET Operators
 -  Set operators are used to combine the results from different SELECT statements into one single result output
 -  Sometimes you want a single output from more than one table
 -  If you join the tables, the rows that meet the join criteria are returned, but what if a join will return a result set that doesn't meet your needs?
 -  This is where SET operators come in
 -  They can return the rows found in multiple SELECT statements, the rows that are in one table and not the other, or the rows common to both statements

```sql
-- The UNION operator returns all rows from both tables, after eliminating duplicates
SELECT a_id
FROM a
  UNION
SELECT b_id
FROM b;

--  The UNION ALL operator returns all rows from both tables, without eliminating duplicates
SELECT a_id
FROM a
  UNION ALL
SELECT b_id
FROM b;

-- The INTERSECT operator returns all rows common to both tables
SELECT a_id
FROM a
  INTERSECT
SELECT b_id
FROM b;

-- The MINUS operator returns all rows found in one table but not the other
-- This is A MINUS B, so all elements in A but not in B
SELECT a_id
FROM a
  MINUS
SELECT b_id
FROM b;
```
#### Set Operator Examples
 -  Sometimes if you are selecting rows from tables that do not have columns in common, you may have to create your own columns in order to match the number of columns in the queries
 -  The easiest way to do this is to include one or more NULL values in the select list
 -  Remember to give each one a suitable alias and matching data type
```sql
SELECT hire_date, employee_id, job_id
FROM employees
  UNION
SELECT TO_DATE(NULL),employee_id,
job_id
FROM job_history;

-- When using ORDER BY only use on one SELECT
SELECT hire_date, employee_id, job_id
FROM employees
  UNION
SELECT TO_DATE(NULL),employee_id, job_id
FROM job_history
ORDER BY employee_id;
```

#### There are a few rules to remember when using SET operators:
 1. The number of columns and the data types of the columns must be identical in all of the SELECT statements used in the query
 2.  The names of the columns need not be identical
 3. Column names in the output are taken from the column names in the first SELECT statement


# 10. Manipulating Data

```sql
INSERT:
INSERT INTO employees (employee_id, first_name) VALUES (300, 'John');

UPDATE:
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 50;

DELETE:
DELETE FROM employees WHERE employee_id = 300;

Transaction Control:
COMMIT       - Save changes permanently
ROLLBACK     - Undo changes
SAVEPOINT sp1;
ROLLBACK TO sp1;
```

# 11. Using DDL Statements to Create and Manage Tables

```sql
CREATE TABLE:
CREATE TABLE departments (
  dept_id NUMBER PRIMARY KEY,
  name VARCHAR2(50) NOT NULL
);

ALTER TABLE:
ALTER TABLE departments ADD (location_id NUMBER);
ALTER TABLE departments MODIFY (name VARCHAR2(100));
ALTER TABLE departments DROP COLUMN location_id;

DROP TABLE:
DROP TABLE departments;

Constraints:
PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK
ALTER TABLE employees ADD CONSTRAINT emp_dept_fk
FOREIGN KEY (department_id) REFERENCES departments(dept_id);
```

# 12. Creating Other Schema Objects

```sql
VIEW:
CREATE VIEW emp_view AS
SELECT first_name, salary FROM employees;

SEQUENCE:
CREATE SEQUENCE emp_seq START WITH 100 INCREMENT BY 1;

INDEX:
CREATE INDEX emp_name_idx ON employees (last_name);

SYNONYM:
CREATE SYNONYM emp FOR employees;
```

