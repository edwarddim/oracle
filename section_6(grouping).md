
# 6. Reporting Aggregated Data Using Group Functions
 -  The keyword DISTINCT is used to return only non-duplicate values or combinations of non-duplicate values in a query
 -  The keyword DISTINCT can be used with all group functions
 - NVL can also be used to replace null values

```sql
NVL(column_name, 0)
SELECT DISTINCT job_id
FROM employees;

SELECT AVG(NVL(commission_pct, 0))
FROM employees;
```
 - Following group functions can operate on a whole table or grouping of rows and produces one result
 - Group functions ignore null values
```sql
COUNT(*)      - Total number of rows
COUNT(col)    - Non-null values only
SUM(col)      - Total of numeric values
AVG(col)      - Average of values
MIN(col)      - Minimum value
MAX(col)      - Maximum value
VARIANCE()
STDDEV()
```
 - Group functions require that any column listed in the SELECT clause that is not part of a group function must be listed in a GROUP BY clause
 - If you include a group function (AVG, SUM, COUNT, MAX, MIN, STDDEV, VARIANCE) in a SELECT clause along with any
other individual columns, each individual column must also appear in the GROUP BY clause
 - You cannot use a column alias in the GROUP BY clause
 - The WHERE clause excludes rows before they are divided into groups
```sql
GROUP BY Example:
SELECT department_id, AVG(salary)
FROM employees
GROUP BY department_id
ORDER BY department_id;

SELECT department_id, MAX(salary)
FROM employees
WHERE last_name != 'King'
GROUP BY department_id;
```

```sql
SELECT MAX(salary), MIN(salary), MIN(employee_id)
FROM employees
WHERE department_id = 60;
```
 - In the same way you used the WHERE clause to restrict the rows that you selected, you can use the HAVING clause to restrict groups
 -  In a query using a GROUP BY and HAVING clause, the rows are first grouped, group functions are applied,
and then only those groups matching the HAVING clause are displayed
 -  The WHERE clause is used to restrict rows; the HAVING clause is used to restrict groups returned from a GROUP BY clause

```sql
HAVING Clause:
SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;

-- This query finds the average population of the countries in each region
-- It then only returns the region groups with a lowest population greater than three hundred thousand
SELECT region_id, ROUND(AVG(population))
FROM wf_countries
GROUP BY region_id
HAVING MIN(population)>300000
ORDER BY region_id;

-- Although the HAVING clause can precede the GROUP BY clause in a SELECT statement, it is recommended that you place each clause in the order shown. ORDER BY GOES LAST!
SELECT column, group_function
FROM table
WHERE
GROUP BY
HAVING
ORDER BY
```
## Rollup
 - In GROUP BY queries, you are quite often required to produce subtotals and totals, and the ROLLUP
operation can do that for you
 - ROLLUP creates subtotals that roll up from the most detailed level to a grand total, using the grouping list
specified in the GROUP BY clause
 -  The action of ROLLUP is straightforward: it creates subtotals that roll up from the most detailed level to a grand total
 -  ROLLUP uses an ordered list of grouping columns in its argument list 
 -  First, it calculates the standard aggregate values specified in the GROUP BY clause
 -  Next, it creates progressively higher-level subtotals, moving from right to left through the list of grouping columns
 -  Finally, it creates a grand total
```sql
-- In the result table below, the rows highlighted in red are generated by the ROLLUP operation
SELECT department_id, job_id, SUM(salary)
FROM employees
WHERE department_id < 50
GROUP BY ROLLUP (department_id, job_id);
```
![Rollup results](/imgs/rollup.png)

## Cube
 -  CUBE, like ROLLUP, is an extension to the GROUP BY clause
 -  It produces cross-tabulation reports
 -  It can be applied to all aggregate functions including AVG, SUM, MIN, MAX, and COUNT
 -  Columns listed in the GROUP BY clause are cross-referenced to create a superset of groups
 -  The aggregate functions specified in the SELECT list are applied to this group to create summary values for the additional super-aggregate rows
 -  CUBE is often used in queries that use columns from separate tables rather than separate columns from a single table
 -  Imagine, for example, a user querying the Sales table for a company like AMAZON.COM
 -  A commonly requested cross-tabulation report might include subtotals for all possible combinations of sales across a Month, Region, and Product

 ```sql
--  In the following statement, the rows in red are generated by the CUBE operation
SELECT department_id, job_id, SUM(salary)
FROM employees
WHERE department_id < 50
GROUP BY CUBE (department_id, job_id);
 ```
![Rollup results](/imgs/coube.png)

## Grouping Sets
 -  GROUPING SETS is another extension to the GROUP BY clause
 -  It is used to specify multiple groupings of data
 -  It gives you the functionality of having multiple GROUP BY clauses in the same SELECT statement, which is not allowed in the normal syntax
 -  If you want to see data from the EMPLOYEES table grouped by (department_id, job_id, manager_id)
 -  But also grouped by (department_id, manager_id)
 -  And also grouped by (job_id, manager_id), then you would normally have to write three different select statements with the only difference between them being the GROUP BY clauses
 - For the database, this means retrieving the same data three different times, and that can be quite a big overhead
 - Imagine if your company had 3,000,000 employees
 - Then you are asking the database to retrieve 9 million rows instead of just 3 million rows â€“ quite a big difference
 - So GROUPING SETS are much more efficient when writing complex reports
![Grouping sets](/imgs/grouping_sets.png)

## Grouping Functions
 -  When you use ROLLUP or CUBE to create reports with subtotals, you quite often also have to be able to tell which rows in the output are actual rows returned from the database and which rows are computed subtotal rows resulting from the ROLLUP or CUBE operations
 -  The GROUPING function handles these problems
 -  Using a single column from the query as its argument, the GROUPING function will return a 1 for an aggregated (computed) row and a 0 for a non- aggregated (returned) row
 -  The syntax for the GROUPING is simply GROUPING (column_name)
 -  It is used only in the SELECT clause and it takes only a single column expression as the argument

```sql
SELECT department_id, job_id, SUM(salary),
  GROUPING(department_id) AS "Dept sub total",
  GROUPING(job_id) AS "Job sub total"
FROM employees
WHERE department_id < 50
GROUP BY CUBE (department_id, job_id);
```
![grouping function](/imgs/grouping_function.png)